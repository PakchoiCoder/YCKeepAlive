#### 基础概念目录介绍
- 01.App进程保活介绍
- 02.常见的保活方法
- 03.思考一些基础问题
- 04.如何查看进程信息
- 05.进程究竟是如何划分
- 06.内存阀值理解和查看
- 07.应用被杀死原因
- 08.白名单进程基础了解






### 01.App进程保活介绍
1,除了微信这样的白名单大佬,没有app可以青春永驻
2,保活只能是使用一些歪门邪道来延长进程的持续时间
3,如果在原生的安卓系统去做,可能会好很多,但介于国内环境,只能尽力而为,有些机型可谓圣斗士一样
4,网上保活方案众多,不可能全部用上,分析使用
5,所谓保活是延长我们核心进程的寿命,比如推送,或者IM,推送其实各厂家做了很多的保活机制,多数为共享长链接,小米这种系统级别的不说,IM也一样,但我们其实也可以在他们的基础上想办法再做一层保活,像个推需要自己集成实现一个service.



### 02.常见的保活方法
1,经典的一像素保活,据说QQ是这门干的(据说),很流氓,很有效,就是在锁屏和解锁的时候创建一个一个像素的Activity,这样做的目的是提升进程的优先级,不过有部分手机好像把解锁屏幕的广播给拿掉了
2,双进程守护,开俩个进程相互唤起,因为系统的进程回收机制是一个个回收的,利用这个时间差来相互唤起,当一个进程被磨灭掉,另一个马上重启,缺点是现在大部分机型只要一键清理就玩完了,不过也没有更好的办法,而且8.0之后对这个做了限制,想要在一个后再服务中启动另一个服务会报错,可以用startForegroundService方法,但是会有一个通知在通知栏,这就有点不太友好了,不过介于8.0以下手机还有很多,可以考虑
3,native进程(已报废)
4,JobIntentService,这个好多人不知道,其实就是之前JobService,利用系统的调度去开启一个服务,不过这个很简单,比JobService的使用简单多了,这个东西会在解锁屏幕,充电啊这一些动作的时候去重启执行里面的job,甚至手机重启,所以用它来总一些事情再核实不过了,不过它也是会被杀死的.
5,利用账号同步机制拉活,不过貌似被改了,失效了
6,在后台播放一个无声的音频,看起来很不错,不过总感觉该方案有点....
7,将service设置为前台进程,通2方法一样,会强制有个通知,可以考虑用innerService发送俩个id一样的通知,然后结束掉一个(8.0之后无效),该方法很好



### 03.思考一些基础问题
- 系统为什么会杀掉进程，app切换到后台后为什么容易被杀死？
- 系统杀的为什么是我的进程，这是按照什么标准来选择的？
- 系统是一次性干掉多个进程，还是一个接着一个杀，为什么？
- 保活套路一堆，方法有很多种，究竟如何进行进程保活才是比较恰当？



### 04.如何查看进程信息
- 如何查看所有的进程信息，直接在命令行输入指令即可，查看设备所有进程信息。
    - 第一步：adb shell；第二步：top
    - 下面这个就是当前所有进程信息，当把一鹿有车切换为前台进程时，所有进程信息如下所示：
    - ![image](https://img-blog.csdnimg.cn/20191218143021181.png)
- 上面显示系统当前的进程状况，那么这些都是代表什么意思呢？
    - 第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。
    - 第二行显示的是全部启动的、眼下执行的、挂起（Sleeping）的和僵尸（Zombie）进程。
    - 第三行显示的是眼下CPU的使用情况，包含系统占用的比例、用户使用比例、闲置（Idle）比例。
    - 第四行显示物理内存的使用情况，包含总的能够使用的内存、已用内存、空暇内存、缓冲区占用的内存。
    - 第五行显示交换分区的使用情况，包含总的交换分区、使用的、空暇的和用于快速缓存的交换分区。
        - PID（Process ID）：进程标志号。是非零正整数
        - USER：进程全部者的username
        - PR：进程的优先级别
        - NI：进程的优先级别数值
        - VIRT：进程占用的虚拟内存值
        - RES：进程占用的物理内存值
        - SHR：进程使用的共享内存值
        - STAT：进程的状态。当中S表示休眠，R表示正在执行，Z表示僵死状态，N表示该进程优先值是负数
        - %CPU：该进程占用的CPU使用率
        - %MEM：该进程占用的物理内存和总内存的百分比
        - TIME：该进程启动后占用的总的CPU时间
- 对于任何一个进程，我们都可以通过adb shell ps | grep 的方式来查看它的基本信息。下面来看一下某个具体app的进程信息……
    - 查询app的包名是：com.cheoo.app。
    - 在命令行中输入查询指令：adb shell "ps |grep com.cheoo"
    - ![image](https://img-blog.csdnimg.cn/20191218145735683.png)
- 那么进程信息查到后，这些信息都是什么意思呢？
    - u0_a288	USER 进程当前用户
    - 20331	    进程ID
    - 541	    进程的父进程ID
    - 5202131	进程的虚拟内存大小
    - 31156	    实际驻留”在内存中”的内存大小
    - com.cheoo.app	    进程名，也就是app的包名
- 观看当前系统进程的变化。你可以反复切换某个app，然后观看该进程的优先级，状态，内存值一直变化。
    - 当app切换到前台时，可以发现该app进程优先级明显增高；




### 05.进程究竟是如何划分
- 前台进程(Foreground process)
    - 场景： 
        - 某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 
        - 某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 
        - 某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 
        - 某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 
        - 某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。
    - 用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。
- 可见进程(Visible process)
    - 场景： 
        - 拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 
        - 拥有绑定到可见（或前台）Activity 的 Service
    - 用户正在使用，看得到，但是摸不着，没有覆盖到整个屏幕,只有屏幕的一部分可见进程不包含任何前台组件，一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活
- 服务进程(Service process)
    - 场景 
        - 某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。
    - 在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死
- 后台进程(Background process)
    - 场景： 
        - 在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onPause方法
    - 系统可能随时终止它们，回收内存
- 空进程(Empty process)
    - 场景： 
        - 某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处,第一个干它!




### 06.内存阀值理解和查看
- 思考以下进程是怎么被杀的呢？
    - 系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。
    - 打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫 Low Memory Killer。
- 那这个不足怎么来规定呢，那就是内存阈值。
    - 可以使用cat /sys/module/lowmemorykiller/parameters/minfree来查看某个手机的内存阈值。 
    - 得到的数值为：18432,23040,27648,32256,36864,46080。那么这几个阀值都是做什么用的呢？
    - 这6个数值分别代表android系统回收6种进程的阈值，这么看不方便查看，转换为M会更直观，这6个数值的单位为page 1page = 4K,所以通过 数值*4/1024就能转换为M:72M,90M,108M,126M,144M,180M
    - 也就是说1.前台进程（foreground），2.可见进程（visible），3.次要服务（secondary server），4.后台进程（hidden），5.内容供应节点（content provider），6.空进程（empty）这6类进程进行回收的内存阈值分别为72M,90M,108M,126M,144M,180M
- 假设内存不足，手机后台进程很多，清除那些进程呢？
    - 或许有一个疑问，假设现在内存不足，空进程都被杀光了，现在要杀后台进程，但是手机中后台进程很多，难道要一次性全部都清理掉？当然不是的，进程是有它的优先级的，这个优先级通过进程的adj值来反映，它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。
- 如何来查找一个进程的oom_adj？
    - 前面已经知道了如何查询某个app的进程，这里就不多说了。com.cheoo.app该进程的进程id是20331，现在开始查询它的adj值。
    - 输入指令：adb shell cat /proc/20331/oom_adj
    - ![image](https://img-blog.csdnimg.cn/20191218152546625.png)
- oom_adj的值是什么意思？
    - 看到adj值是0，0就代表这个进程是属于前台进程。按下home键，将应用至于后台，再次查看值为11，这adj级别值怎么解释呢。
    - UNKNOWN_ADJ	16	预留的最低级别，一般对于缓存的进程才有可能设置成这个级别
    - CACHED_APP_MAX_ADJ	15	缓存进程，空进程，在内存不足的情况下就会优先被kill
    - CACHED_APP_MIN_ADJ	9	缓存进程，也就是空进程
    - SERVICE_B_ADJ	8	不活跃的进程
    - PREVIOUS_APP_ADJ	7	切换进程
    - HOME_APP_ADJ	6	与Home交互的进程
    - SERVICE_ADJ	5	有Service的进程
    - HEAVY_WEIGHT_APP_ADJ	4	高权重进程
    - BACKUP_APP_ADJ	3	正在备份的进程
    - PERCEPTIBLE_APP_ADJ	2	可感知的进程，比如那种播放音乐
    - VISIBLE_APP_ADJ	1	可见进程
    - FOREGROUND_APP_ADJ	0	前台进程
    - PERSISTENT_SERVICE_ADJ	-11	重要进程
    - PERSISTENT_PROC_ADJ	-12	核心进程
    - SYSTEM_ADJ	-16	系统进程
    - NATIVE_ADJ	-17	系统起的Native进程
- 根据oom_adj值对应用保活有啥意义？
    - 根据上面的adj值，其实系统在进程回收跟内存回收类似也是有一套严格的策略，大概是这个样子的，oom_adj越大，占用物理内存越多会被最先kill掉，那么现在对于进程如何保活这个问题就转化成，如何降低oom_adj的值，以及如何使得我们应用占的内存最少。




### 07.应用被杀死原因
- 在Android系统里，进程被杀的原因通常为以下几个方面：
    - a.应用Crash
    - b.系统回收内存（系统资源不足的时候）
    - c.用户触发（用户手动退出）
    - d.第三方root权限app（用户手动调用某些安全软件的清理功能干掉你的后台应用）
- 目前app保活主要针对的是，对系统回收内存进行优化，以避免进程被轻易杀死。



### 08.白名单进程基础了解


### 参考文章
- https://blog.csdn.net/blueangle17/article/details/86678533
- https://www.jianshu.com/p/dd01580743e7
- https://blog.csdn.net/tubby_ting/article/details/52830654
- https://segmentfault.com/a/1190000020159573?utm_source=tag-newest
- https://github.com/jiangdongguo/KeepingAppAlive
- https://github.com/fanqieVip/keeplive



- Android lowmemorykiller分析：https://blog.csdn.net/u011733869/article/details/78820240







