#### 基础概念目录介绍
- 01.App进程保活介绍
- 02.常见的保活方法
- 03.思考一些基础问题
- 04.如何查看进程信息
- 05.进程究竟是如何划分
- 06.内存阀值理解和查看
- 07.应用被杀死原因
- 08.白名单进程基础了解






### 01.App进程保活介绍
1,除了微信这样的白名单大佬,没有app可以青春永驻
2,保活只能是使用一些歪门邪道来延长进程的持续时间
3,如果在原生的安卓系统去做,可能会好很多,但介于国内环境,只能尽力而为,有些机型可谓圣斗士一样
4,网上保活方案众多,不可能全部用上,分析使用
5,所谓保活是延长我们核心进程的寿命,比如推送,或者IM,推送其实各厂家做了很多的保活机制,多数为共享长链接,小米这种系统级别的不说,IM也一样,但我们其实也可以在他们的基础上想办法再做一层保活,像个推需要自己集成实现一个service.



### 02.常见的保活方法
1,经典的一像素保活,据说QQ是这门干的(据说),很流氓,很有效,就是在锁屏和解锁的时候创建一个一个像素的Activity,这样做的目的是提升进程的优先级,不过有部分手机好像把解锁屏幕的广播给拿掉了
2,双进程守护,开俩个进程相互唤起,因为系统的进程回收机制是一个个回收的,利用这个时间差来相互唤起,当一个进程被磨灭掉,另一个马上重启,缺点是现在大部分机型只要一键清理就玩完了,不过也没有更好的办法,而且8.0之后对这个做了限制,想要在一个后再服务中启动另一个服务会报错,可以用startForegroundService方法,但是会有一个通知在通知栏,这就有点不太友好了,不过介于8.0以下手机还有很多,可以考虑
3,native进程(已报废)
4,JobIntentService,这个好多人不知道,其实就是之前JobService,利用系统的调度去开启一个服务,不过这个很简单,比JobService的使用简单多了,这个东西会在解锁屏幕,充电啊这一些动作的时候去重启执行里面的job,甚至手机重启,所以用它来总一些事情再核实不过了,不过它也是会被杀死的.
5,利用账号同步机制拉活,不过貌似被改了,失效了
6,在后台播放一个无声的音频,看起来很不错,不过总感觉该方案有点....
7,将service设置为前台进程,通2方法一样,会强制有个通知,可以考虑用innerService发送俩个id一样的通知,然后结束掉一个(8.0之后无效),该方法很好



### 03.思考一些基础问题
- 系统为什么会杀掉进程，app切换到后台后为什么容易被杀死？
- 系统杀的为什么是我的进程，这是按照什么标准来选择的？
- 系统是一次性干掉多个进程，还是一个接着一个杀，为什么？
- 保活套路一堆，方法有很多种，究竟如何进行进程保活才是比较恰当？


### 04.如何查看进程信息


### 05.进程究竟是如何划分
- 前台进程(Foreground process)
    - 场景： 
        - 某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 
        - 某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 
        - 某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 
        - 某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 
        - 某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。
    - 用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。
- 可见进程(Visible process)
    - 场景： 
        - 拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 
        - 拥有绑定到可见（或前台）Activity 的 Service
    - 用户正在使用，看得到，但是摸不着，没有覆盖到整个屏幕,只有屏幕的一部分可见进程不包含任何前台组件，一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活
- 服务进程(Service process)
    - 场景 
        - 某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。
    - 在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死
- 后台进程(Background process)
    - 场景： 
        - 在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onPause方法
    - 系统可能随时终止它们，回收内存
- 空进程(Empty process)
    - 场景： 
        - 某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处,第一个干它!



### 06.内存阀值理解和查看
- 进程是怎么被杀的呢？系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。
- 打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫 Low Memory Killer。
- 那这个不足怎么来规定呢，那就是内存阈值，我们可以使用cat /sys/module/lowmemorykiller/parameters/minfree来查看某个手机的内存阈值。 



### 07.应用被杀死原因
- 在Android系统里，进程被杀的原因通常为以下几个方面：
    - a.应用Crash
    - b.系统回收内存（系统资源不足的时候）
    - c.用户触发（用户手动退出）
    - d.第三方root权限app（用户手动调用某些安全软件的清理功能干掉你的后台应用）
- 目前app保活主要针对的是，对系统回收内存进行优化，以避免进程被轻易杀死。



### 08.白名单进程基础了解


### 参考文章
- Android 实现进程保活：https://blog.csdn.net/u013233097/article/details/99990206
- https://blog.csdn.net/blueangle17/article/details/86678533
- https://www.jianshu.com/p/dd01580743e7
- https://blog.csdn.net/tubby_ting/article/details/52830654
- https://segmentfault.com/a/1190000020159573?utm_source=tag-newest
- https://github.com/jiangdongguo/KeepingAppAlive
- https://github.com/fanqieVip/keeplive











